''' A program to assist in decoding O-LLVM code. '''
import sys
import collections

def get_indent(line):
    i = 0
    for c in line:
        if c != ' ':
            break
        i += 1
    return i

class CNode:
    def __init__(self, line, children=None):
        self.line = line
        if children is None:
            children = []
        self.children = children
    def pprint(self, indent=0, check=False):
        if check:
            assert get_indent(self.line) == indent
        print ' ' * indent + self.line.lstrip()
        if self.children:
            print ' '*indent + '{'
            for node in self.children:
                node.pprint(indent + 2, check=check)
            print ' '*indent + '}'
    def __repr__(self):
        return '%s(%r, %r)' % (self.__class__.__name__, self.line, self.children)

# Parse strictly-indented code generated by IDA.
def parse_ida_c(lines, ln=0, parindent=-2):
    out = []
    curline = []

    while ln < len(lines):
        if not lines[ln]:
            ln += 1
            continue
        ni = get_indent(lines[ln])
        if ni == parindent:
            break
        elif ni == parindent + 2:
            # same level
            if lines[ln].lstrip().startswith('{'):
                curline.append(lines[ln])
            elif lines[ln].lstrip().startswith('}'):
                pass
            else:
                if curline:
                    out.append(CNode('\n'.join(curline)))
                curline = [lines[ln]]
        elif ni == parindent + 4:
            # start of a subnode
            if curline[-1].startswith(' ' * (parindent+2) + '{'):
                curline.pop()
                expect_brace = True
            else:
                expect_brace = False
            children, ln = parse_ida_c(lines, ln, parindent + 2)
            if expect_brace:
                if not lines[ln].startswith(' ' * (parindent+2) + '}'):
                    raise ValueError("no close brace on line %d" % (ln+1))
            else:
                if lines[ln].startswith(' ' * (parindent+2) + '}'):
                    raise ValueError("stray close brace on line %d" % (ln+1))
            out.append(CNode('\n'.join(curline), children))
            curline = []
            continue
        elif ni == 0 and re.match(r'LABEL\w+:', lines[ln]):
            # label
            out.append(CNode('\n'.join(curline)))
            curline = [' '*(parindent + 2) + lines[ln]]
        elif ni < parindent:
            # multiple unindent (e.g. after an unbraced block)
            break
        else:
            # this is usually a wrapped line
            print >> sys.stderr, "Warning: unknown indent transition %d->%d at line %d" % (parindent, ni, ln)
            curline.append(lines[ln])
        ln += 1
    if curline:
        out.append(CNode('\n'.join(curline)))

    return (out, ln)

import re
re_num = r'-?\d\w*'
def mklabel(n):
    n = int(n.rstrip('L').rstrip('U'), 0)
    if n >= 1<<31:
        n -= 1<<32
    return '_L%s' % (str(n).replace('-', 'n'))

class CtrlFlowUnflattener:
    def __init__(self, var):
        ''' Unflatten the control flow of some IDA pseudocode function, heuristically

        func_node: CNode for the function
        var: variable name used to label each node
        returns: transformed C code that can be compiled and theoretically reversed with less pain
        '''
        self.var = var
        self.bbs = {} # basic blocks
        self.bb_refs = collections.defaultdict(list)
        self.lbl_vars = set()

    def _mk_tree(self, start):
        visited = {start}
        def recurse(node):
            out = []
            maxht = 0
            for child in self.bb_refs[node]:
                if child in visited:
                    continue
                visited.add(child)
                n, nodes, ht = recurse(child)
                if ht > maxht:
                    maxht = ht
                out.append((n, nodes, ht))
            return (node, out, maxht+1)
        return recurse(start)

    def _tree_sort(self, tree, lbls):
        out = []
        def recurse((node, children, ht)):
            children.sort(key=lambda x: x[2]) # sort by height
            if node in lbls:
                out.append(node)
            for c in children:
                recurse(c)
        recurse(tree)
        return out

    def unflatten(self, func_node):
        # Find initial block
        top = func_node.children
        init_label = None
        for i in xrange(len(top)):
            m = re.match(r' *\b%s\b = (%s);' % (self.var, re_num), top[i].line)
            if m:
                top[i] = CNode('goto %s;' % mklabel(m.group(1)))
                init_label = mklabel(m.group(1))
                break
        else:
            raise ValueError("No starting block found!")

        # Find main loop
        while_re = r' *while \( %s != (%s) \)' % (self.var, re_num)
        for i in xrange(len(top)):
            line = top[i].line
            if re.match(r' *do\b', line):
                m = re.match(while_re, top[i+1].line)
                if m:
                    top[i:i+2] = self.unflatten_loop(top[i].children) + [CNode(mklabel(m.group(1)) + ':')]
                    self.bbs[mklabel(m.group(1))] = None
                    break

            m = re.match(while_re, top[i].line)
            if m:
                top[i:i+1] = self.unflatten_loop(top[i].children) + [CNode(mklabel(m.group(1)) + ':')]
                self.bbs[mklabel(m.group(1))] = None
                break

            m = re.match(r' *while \( 1 \)', top[i].line)
            if m:
                # infinite loop toplevel
                top[i:i+1] = self.unflatten_loop(top[i].children)
                break

        else:
            raise ValueError("No main loop found!")

        # Fix basic blocks
        for label in self.bbs:
            if self.bbs[label] is not None:
                self.convert_bb(self.bbs[label], label)

        # Insert new label variables
        top[:0] = [CNode('void *%s_lbl;' % i) for i in self.lbl_vars]

        # Toposort the basic blocks
        newtop = []
        all_bbs = {v:k for k,v in self.bbs.iteritems()}
        top_bbs = set()
        bb_start_index = None
        for i in xrange(len(top)):
            if top[i] in all_bbs:
                if bb_start_index is None:
                    bb_start_index = i
                top_bbs.add(all_bbs[top[i]])
            else:
                newtop.append(top[i])

        tree = self._mk_tree(init_label)
        new_bbs = self._tree_sort(tree, top_bbs)
        orphan = list(top_bbs - set(new_bbs))
        if orphan:
            print >> sys.stderr, "Warning: orphan blocks: %s" % orphan
        non_tl = list(set(self.bbs) - top_bbs)
        if non_tl:
            print >> sys.stderr, "Warning: non-top-level blocks: %s" % non_tl
        newtop[bb_start_index:bb_start_index] = [self.bbs[lbl] for lbl in new_bbs + orphan]
        func_node.children = newtop

        return func_node

    def unflatten_loop(self, nodes):
        out = []
        for n in nodes:
            if re.match(r' *while \( 1 \)', n.line):
                # remove this loop
                out += self.unflatten_loop(n.children)
                continue
            elif re.match(r' *(?:if|else if|while) \( %s (?:<=|<|>|>=) %s \)' % (self.var, re_num), n.line):
                # remove this useless test
                out += self.unflatten_loop(n.children)        
                continue
            elif re.match(r' *else$', n.line):
                # remove this useless test
                out += self.unflatten_loop(n.children)        
                continue
            elif re.match(r' *break;', n.line):
                # debris from removing an outer loop
                continue

            m = re.match(r' *(?:if|else if|while) \( %s == (%s) \)' % (self.var, re_num), n.line)
            if m:
                # convert to basic block
                bb = CNode(mklabel(m.group(1)) + ':', n.children)
                self.bbs[mklabel(m.group(1))] = bb
                out.append(bb)
                continue

            m = re.match(r' *switch \( %s \)' % self.var, n.line)
            if m:
                # convert all cases to basic blocks
                for cn in n.children:
                    m = re.match(r' *case (%s):' % re_num, cn.line)
                    if m:
                        # kill break statements
                        children = [c for c in cn.children if not re.match(r' *break;', c.line)]
                        bb = CNode(mklabel(m.group(1)) + ':', children)
                        self.bbs[mklabel(m.group(1))] = bb
                        out.append(bb)
                    else:
                        print >> sys.stderr, "Warning: unrecognized switch-case %s" % cn.line
                        out.append(cn) # broken, user must fix
            else:
                out.append(n)
        return out

    def convert_bb(self, bb, lbl):
        out = []
        for n in bb.children:
            m = re.match(' *(\w+) = (%s)' % re_num, n.line)
            if m and mklabel(m.group(2)) in self.bbs:
                if m.group(1) == self.var:
                    # plain goto
                    out.append(CNode('goto %s;' % mklabel(m.group(2))))
                else:
                    # computed goto
                    self.lbl_vars.add(m.group(1))
                    out.append(CNode('%s_lbl = &&%s;' % (m.group(1), mklabel(m.group(2)))))
                self.bb_refs[lbl].append(mklabel(m.group(2)))
                continue

            m = re.match(' *%s = (\w+)' % self.var, n.line)
            if m and m.group(1) in self.lbl_vars:
                # computed goto
                out.append(CNode('goto *%s_lbl;' % m.group(1)))
                continue

            self.convert_bb(n, lbl)
            out.append(n)
        bb.children = out
            
def unflatten_func_source(func_node, var):
    return CtrlFlowUnflattener(var).unflatten(func_node)
